<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ì–‘ì¹˜ê¸° ìƒì¡´ ê²Œì„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: none;
            overflow: hidden;
            background-color: #333;
        }
        canvas {
            background-color: #6aa84f; /* ë‚® ë°°ê²½ìƒ‰ */
            cursor: pointer;
            display: block;
            border-radius: 0.5rem;
        }
        .hud-item {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .modal {
            background-color: rgba(0, 0, 0, 0.7);
        }
        .modal-content {
            background-color: #f0f0f0;
            color: #333;
        }
        .joystick {
            width: 120px;
            height: 120px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            position: absolute;
            bottom: 30px;
            left: 30px;
        }
        .joystick-handle {
            width: 60px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            position: absolute;
            top: 30px;
            left: 30px;
        }
        /* ìˆ«ì ì…ë ¥ í•„ë“œì˜ í™”ì‚´í‘œ ìˆ¨ê¸°ê¸° */
        input[type=number]::-webkit-inner-spin-button,
        input[type=number]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type=number] {
            -moz-appearance: textfield;
        }
        /* ê²Œì„ ë¡œê·¸ ìŠ¤íƒ€ì¼ */
        #game-log {
            font-family: monospace;
            line-height: 1.2;
        }
    </style>
</head>
<body class="w-screen h-screen flex items-center justify-center p-2">

    <div id="game-container" class="relative w-full h-full max-w-screen-lg max-h-screen-md aspect-video">
        <canvas id="gameCanvas"></canvas>

        <!-- HUD -->
        <div class="absolute top-2 left-2 right-2 flex justify-between items-start gap-2">
            <div class="flex flex-col sm:flex-row gap-2">
                <div id="time-hud" class="hud-item"><span>ğŸ•’</span> <span id="time-display">ì˜¤ì „ 06:00</span></div>
                <div id="day-hud" class="hud-item"><span>ğŸ—“ï¸</span> <span id="day-display">Day 1</span></div>
            </div>
            <div class="flex flex-col sm:flex-row gap-2 items-end">
                <div id="gold-hud" class="hud-item"><span>ğŸ’°</span> <span id="gold-display">10</span></div>
                <div id="sheep-hud" class="hud-item"><span>ğŸ‘</span> <span id="sheep-display">5</span></div>
                <div id="hay-hud" class="hud-item"><span>ğŸŒ¾</span> <span id="hay-display">0</span></div>
                <!-- New HUD item for wolf skin -->
                <div id="wolf-skin-hud" class="hud-item"><span>ğŸº</span> <span id="wolf-skin-display">0</span></div>
            </div>
        </div>
        
        <!-- ê°œ ìƒíƒœ UI -->
        <div id="dog-status-ui" class="absolute bottom-2 left-1/2 -translate-x-1/2 flex gap-2"></div>

        <!-- ìƒí˜¸ì‘ìš© ë²„íŠ¼ë“¤ -->
        <div class="absolute bottom-2 right-2 flex flex-col gap-2">
            <button id="hay-action-button" class="hidden hud-item"></button>
            <button id="gate-button" class="hidden hud-item"> ë¬¸ ë‹«ê¸°</button>
            <button id="market-button" class="hidden hud-item">ğŸ›’ ì‹œì¥</button>
            <button id="dog-command-all-button" class="hidden hud-item">ğŸ¾ ì „ì²´ ëª…ë ¹</button>
        </div>

        <!-- ì¡°ì´ìŠ¤í‹± (ëª¨ë°”ì¼ ì „ìš©) -->
        <div id="joystick" class="joystick hidden">
            <div id="joystick-handle" class="joystick-handle"></div>
        </div>

        <!-- ê²Œì„ ë¡œê·¸ -->
        <div id="game-log" class="absolute bottom-2 left-2 w-1/4 max-w-xs h-1/4 bg-black bg-opacity-50 text-white p-2 rounded-lg overflow-y-auto text-xs">
            <p class="font-bold mb-1">ê²Œì„ ë¡œê·¸</p>
            <!-- Log messages will be appended here -->
        </div>

    </div>

    <!-- ëª¨ë‹¬ ì°½ë“¤ -->
    <div id="market-modal" class="modal hidden absolute inset-0 flex items-center justify-center p-4">
        <div class="modal-content w-full max-w-lg p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">ì‹œì¥</h2>
                <button onclick="game.ui.toggleMarketModal(false)" class="text-2xl font-bold">&times;</button>
            </div>
            <div id="market-message" class="text-center text-red-600 mb-4 hidden"></div> <!-- Added for messages -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div id="market-buy-section">
                    <h3 class="font-bold mb-2 text-lg">êµ¬ë§¤</h3>
                </div>
                <div id="market-sell-section">
                    <h3 class="font-bold mb-2 text-lg">íŒë§¤</h3>
                </div>
            </div>
        </div>
    </div>

    <div id="hay-modal" class="modal hidden absolute inset-0 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 id="hay-modal-title" class="text-2xl font-bold">ê±´ì´ˆ ê´€ë¦¬</h2>
                <button onclick="game.ui.toggleHayModal(false)" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="space-y-4">
                <p id="hay-modal-info"></p>
                <div class="flex items-center justify-center gap-2">
                    <button id="hay-quantity-minus" class="bg-gray-300 px-4 py-2 rounded-md font-bold">-</button>
                    <input id="hay-quantity-input" type="number" class="w-24 text-center text-lg font-bold border rounded-md" value="1" min="1">
                    <button id="hay-quantity-plus" class="bg-gray-300 px-4 py-2 rounded-md font-bold">+</button>
                </div>
                <input id="hay-quantity-slider" type="range" class="w-full" value="1" min="1">
                <button id="hay-confirm-button" class="w-full bg-green-500 text-white p-2 rounded-md hover:bg-green-600">í™•ì¸</button>
            </div>
        </div>
    </div>

    <div id="sheep-info-modal" class="modal hidden absolute inset-0 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">ì–‘ ì •ë³´</h2>
                <button onclick="game.ui.toggleSheepInfoModal(false)" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="sheep-name-input" class="block text-sm font-medium text-gray-700">ì´ë¦„</label>
                    <input id="sheep-name-input" type="text" class="w-full p-2 border rounded-md mt-1">
                </div>
                <div>
                    <p class="text-sm font-medium text-gray-700">ìƒíƒœ</p>
                    <p id="sheep-status-info" class="mt-1 p-2 bg-gray-100 rounded-md"></p>
                </div>
                <button id="sheep-info-confirm" class="w-full bg-blue-500 text-white p-2 rounded-md hover:bg-blue-600">í™•ì¸</button>
            </div>
        </div>
    </div>

    <div id="dog-info-modal" class="modal hidden absolute inset-0 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-lg shadow-xl">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-2xl font-bold">ê°œ ì •ë³´</h2>
                <button onclick="game.ui.toggleDogInfoModal(false)" class="text-2xl font-bold">&times;</button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="dog-name-input" class="block text-sm font-medium text-gray-700">ì´ë¦„</label>
                    <input id="dog-name-input" type="text" class="w-full p-2 border rounded-md mt-1">
                </div>
                <button id="dog-info-confirm" class="w-full bg-blue-500 text-white p-2 rounded-md hover:bg-blue-600">í™•ì¸</button>
            </div>
        </div>
    </div>
    
    <div id="game-over-modal" class="modal hidden absolute inset-0 flex items-center justify-center">
        <div class="modal-content w-11/12 max-w-md p-6 rounded-lg shadow-xl text-center">
            <h2 class="text-3xl font-bold mb-4">ê²Œì„ ì˜¤ë²„</h2>
            <p id="game-over-stats" class="mb-6"></p>
            <button onclick="window.location.reload()" class="bg-blue-500 text-white p-3 rounded-md hover:bg-blue-600 text-lg">ë‹¤ì‹œ ì‹œì‘í•˜ê¸°</button>
        </div>
    </div>

    <!-- ìƒˆë¡œìš´ í™•ì¸ ëª¨ë‹¬ -->
    <div id="confirm-modal" class="modal hidden absolute inset-0 flex items-center justify-center p-4">
        <div class="modal-content w-11/12 max-w-sm p-6 rounded-lg shadow-xl text-center">
            <p id="confirm-message" class="text-lg font-semibold mb-6"></p>
            <div class="flex justify-center gap-4">
                <button id="confirm-yes-button" class="bg-green-500 text-white p-2 rounded-md hover:bg-green-600 flex-1">ì˜ˆ</button>
                <button id="confirm-no-button" class="bg-red-500 text-white p-2 rounded-md hover:bg-red-600 flex-1">ì•„ë‹ˆì˜¤</button>
            </div>
        </div>
    </div>

    <script>
        // --- ê²Œì„ ì„¤ì • ---
        const config = {
            TIME_SCALE: 100, // ì‹œê°„ íë¦„ ì†ë„ (ë‚®ì„ìˆ˜ë¡ ë¹ ë¦„)
            DAY_DURATION: 12 * 60, // 12ì‹œê°„ (ê²Œì„ ì‹œê°„ ë¶„ ë‹¨ìœ„)
            SHEPHERD_SPEED: 2,
            SHEEP_SPEED: 1.5,
            DOG_SPEED: 2.5,
            WOLF_SPEED: 1.8,
            WOLF_SPAWN_TIME: 21 * 60, // ì˜¤í›„ 9ì‹œ
            GRASS_TILE_SIZE: 20,
            GRASS_EATING_DELAY: 2000, // í’€ì„ ë¨¹ëŠ” ë”œë ˆì´ (ë°€ë¦¬ì´ˆ)
        };

        // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
        const utils = {
            distance(p1, p2) {
                return Math.sqrt((p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2);
            },
            isMobile() {
                return /Mobi|Android/i.test(navigator.userAgent);
            }
        };
        
        // --- ê²Œì„ í´ë˜ìŠ¤ ---
        class Game {
            constructor(canvas) {
                this.idCounters = { dog: 0 };
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.entities = [];
                this.leaderSheep = null;
                this.gameState = {
                    time: 6 * 60, // ì˜¤ì „ 6ì‹œ ì‹œì‘
                    day: 1,
                    gold: 10,
                    hayStock: 0,
                    wolfSkin: 0, // ëŠ‘ëŒ€ ê°€ì£½ ì¶”ê°€
                    isNight: false,
                    gameOver: false,
                    paused: false,
                };
                this.world = {
                    width: 2000,
                    height: 1500,
                    pasture: { 
                        x: 800, y: 550, width: 400, height: 400, 
                        gate: { x: 960, y: 950, width: 80, height: 20, isOpen: true },
                        // Trough now has tiles
                        trough: {
                            x: 820, y: 600, width: 200, height: 20, // Increased width for 10 tiles
                            troughTiles: [], // Array to hold individual hay tiles
                            maxHayPerTile: 3,
                            numTroughTiles: 10,
                            hayAmount: 0 // Will be calculated dynamically
                        },
                        haystack: { x: 1150, y: 880, radius: 30 }
                    },
                    grassPatches: []
                };

                // [ìˆ˜ì •] ìš¸íƒ€ë¦¬ ë°– 10ì¹¸ì„ ì œì™¸í•œ ëª¨ë“  ê³µê°„ì„ í’€ë¡œ ì±„ìš°ë„ë¡ ë³€ê²½
                const p = this.world.pasture;
                const margin = 10 * config.GRASS_TILE_SIZE; // 10ì¹¸ = 200 í”½ì…€

                const noGrassZone = {
                    x: p.x - margin,
                    y: p.y - margin,
                    width: p.width + margin * 2,
                    height: p.height + margin * 2
                };

                // noGrassZoneì„ ì œì™¸í•œ 4ê°œì˜ ì‚¬ê°í˜• ì˜ì—­ì— í’€ ìƒì„±
                this.initializeGrassPatches([
                    // Top patch
                    { x: 0, y: 0, width: this.world.width, height: noGrassZone.y },
                    // Bottom patch
                    { x: 0, y: noGrassZone.y + noGrassZone.height, width: this.world.width, height: this.world.height - (noGrassZone.y + noGrassZone.height) },
                    // Left patch
                    { x: 0, y: noGrassZone.y, width: noGrassZone.x, height: noGrassZone.height },
                    // Right patch
                    { x: noGrassZone.x + noGrassZone.width, y: noGrassZone.y, width: this.world.width - (noGrassZone.x + noGrassZone.width), height: noGrassZone.height }
                ]);


                // Initialize trough tiles
                this.initializeTroughTiles();
                // Calculate initial hay amount
                this.world.pasture.trough.hayAmount = this.calculateTroughHayAmount();


                this.camera = { x: 0, y: 0 };
                this.input = new InputHandler(this);
                this.ui = new UI(this);
                this.market = new Market(this);
                this.lastTime = 0;
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());

                this.logDisplay = document.getElementById('game-log'); // Get the log element
                this._lastStartedDay = 0; // Prevent startOfDay from being called multiple times per day
                this._lastEndedDay = 0; // Prevent endOfDay from being called multiple times per day
            }

            initializeGrassPatches(patches) {
                patches.forEach(p => {
                    // Ensure width and height are non-negative
                    if (p.width <= 0 || p.height <= 0) return;
                    
                    const patch = { ...p, tiles: [] };
                    const cols = Math.floor(p.width / config.GRASS_TILE_SIZE);
                    const rows = Math.floor(p.height / config.GRASS_TILE_SIZE);
                    for (let r = 0; r < rows; r++) {
                        patch.tiles[r] = [];
                        for (let c = 0; c < cols; c++) {
                            // [ìˆ˜ì •] í’€ íƒ€ì¼ì— ì¬ìƒì„± íƒ€ì´ë¨¸ ì¶”ê°€
                            patch.tiles[r][c] = { richness: 1, maxRichness: 3, regrowthTimer: 0 };
                        }
                    }
                    this.world.grassPatches.push(patch);
                });
            }

            initializeTroughTiles() {
                const trough = this.world.pasture.trough;
                trough.troughTiles = [];
                for (let i = 0; i < trough.numTroughTiles; i++) {
                    trough.troughTiles.push({ richness: 0, maxRichness: trough.maxHayPerTile });
                }
            }
            // New helper to calculate total hay in trough
            calculateTroughHayAmount() {
                const trough = this.world.pasture.trough;
                return trough.troughTiles.reduce((sum, tile) => sum + tile.richness, 0);
            }
            // New helper to calculate total max hay in trough
            calculateTroughMaxHay() {
                const trough = this.world.pasture.trough;
                return trough.numTroughTiles * trough.maxHayPerTile;
            }

            // ê²Œì„ ì‹œì‘
            start() {
                this.shepherd = new Shepherd(this, this.world.pasture.x + 50, this.world.pasture.y + 50);
                this.entities.push(this.shepherd);
                this.entities.push(new Dog(this, this.shepherd.x - 30, this.shepherd.y));
                for (let i = 0; i < 5; i++) {
                    this.entities.push(new Sheep(this, this.world.pasture.x + 100 + Math.random() * 200, this.world.pasture.y + 100 + Math.random() * 200, true));
                }
                this.gameLoop(0);
            }

            // ë©”ì¸ ê²Œì„ ë£¨í”„
            gameLoop(timestamp) {
                if (this.gameState.gameOver) return;
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;
                if (!this.gameState.paused) this.update(deltaTime);
                this.draw();
                requestAnimationFrame(this.gameLoop.bind(this));
            }

            // ê²Œì„ ìƒíƒœ ì—…ë°ì´íŠ¸
            update(deltaTime) {
                this.updateTime(deltaTime);
                this.updateLeaderSheep();
                this.entities = this.entities.filter(e => !e.isDead); // ì£½ì€ ì—”í‹°í‹° ì œê±°
                // Call input.update() here to get the latest input state before other entities update
                this.input.update(); // InputHandlerì˜ update í˜¸ì¶œ
                this.entities.forEach(e => e.update(deltaTime));
                this.spawnWolves();
                this.updateCamera();
                this.ui.update();
                this.checkGameOver();
            }
            
            // ê·¸ë¦¬ê¸°
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.save();
                this.ctx.translate(-this.camera.x, -this.camera.y);
                this.drawBackground();
                this.entities.sort((a, b) => a.y - b.y).forEach(e => e.draw(this.ctx));
                this.ctx.restore();
            }
            
            // ë°°ê²½ ê·¸ë¦¬ê¸°
            drawBackground() {
                this.ctx.fillStyle = this.gameState.isNight ? '#4a7c3a' : '#6aa84f';
                this.ctx.fillRect(0, 0, this.world.width, this.world.height);
                
                // í’€ë°­ íƒ€ì¼ ê·¸ë¦¬ê¸°
                this.world.grassPatches.forEach(p => {
                    for (let r = 0; r < p.tiles.length; r++) {
                        for (let c = 0; c < p.tiles[r].length; c++) {
                            const tile = p.tiles[r][c];
                            if (tile.richness > 0) {
                                const alpha = tile.richness / tile.maxRichness * 0.7 + 0.3;
                                this.ctx.fillStyle = this.gameState.isNight ? `rgba(56, 102, 65, ${alpha})` : `rgba(88, 129, 87, ${alpha})`;
                                this.ctx.fillRect(p.x + c * config.GRASS_TILE_SIZE, p.y + r * config.GRASS_TILE_SIZE, config.GRASS_TILE_SIZE, config.GRASS_TILE_SIZE);
                                
                                // í’€ ìˆ˜ì¹˜ í‘œì‹œ: ìˆ«ì â†’ ë¨¹ì´í†µ ìŠ¤íƒ€ì¼ ì„¸ë¡œ ì±„ì›€ ë°”
                                const tileX = p.x + c * config.GRASS_TILE_SIZE;
                                const tileY = p.y + r * config.GRASS_TILE_SIZE;
                                const s = config.GRASS_TILE_SIZE;
                                // ì™¸ê³½ì„ 
                                this.ctx.strokeStyle = 'rgba(0,0,0,0.25)';
                                this.ctx.lineWidth = 1;
                                this.ctx.strokeRect(tileX + 2, tileY + 2, s - 4, s - 4);
                                // ì±„ì›€
                                const _max = (tile.maxRichness ?? 3);
                                const _ratio = Math.max(0, Math.min(1, tile.richness / _max));
                                const _fillH = (s - 6) * _ratio;
                                this.ctx.fillStyle = '#6fcf6f';
                                this.ctx.fillRect(tileX + 3, tileY + (s - 3) - _fillH, s - 6, _fillH);
                            }
                        }
                    }
                });

                const p = this.world.pasture;
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 10;
                this.ctx.strokeRect(p.x, p.y, p.width, p.height);
                
                // Draw outer trough structure
                this.ctx.fillStyle = '#A0522D';
                this.ctx.fillRect(p.trough.x, p.trough.y, p.trough.width, p.trough.height); // Draw the base trough

                // Draw trough tiles
                const troughTileWidth = p.trough.width / p.trough.numTroughTiles;
                const troughTileHeight = p.trough.height;
                p.trough.troughTiles.forEach((tile, index) => {
                    if (tile.richness > 0) {
                        const fillRatio = tile.richness / tile.maxRichness;
                        const hayFillHeight = troughTileHeight * fillRatio;
                        this.ctx.fillStyle = '#f0e68c'; // Hay color
                        this.ctx.fillRect(
                            p.trough.x + index * troughTileWidth,
                            p.trough.y + troughTileHeight - hayFillHeight,
                            troughTileWidth,
                            hayFillHeight
                        );
                    }
                    // Draw lines between trough tiles for visual separation
                    this.ctx.strokeStyle = '#8B4513'; // Darker color for trough lines
                    this.ctx.lineWidth = 1;
                    this.ctx.strokeRect(
                        p.trough.x + index * troughTileWidth,
                        p.trough.y,
                        troughTileWidth,
                        troughTileHeight
                    );
                });


                this.ctx.fillStyle = '#DAA520';
                this.ctx.beginPath();
                this.ctx.arc(p.haystack.x, p.haystack.y, p.haystack.radius, 0, Math.PI * 2);
                this.ctx.fill();
                
                const gate = p.gate;
                if (gate.isOpen) {
                    this.ctx.clearRect(gate.x, gate.y - 5, gate.width, gate.height);
                } else {
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(gate.x, gate.y - 5, gate.width, gate.height);
                }
            }

            // ì‹œê°„ ê´€ë¦¬
            updateTime(deltaTime) {
                const prevHour = Math.floor((this.gameState.time - deltaTime / config.TIME_SCALE) / 60);
                this.gameState.time += deltaTime / config.TIME_SCALE;
                const currentHour = Math.floor(this.gameState.time / 60);

                // ìì •ì„ ë„˜ì–´ê°€ë©´ ë‚ ì§œ ë³€ê²½ ë° endOfDay í˜¸ì¶œ
                if (this.gameState.time >= 24 * 60) {
                    this.gameState.time = this.gameState.time % (24 * 60); // 0ë¶€í„° 23:59:59ê¹Œì§€ ìœ ì§€
                    this.gameState.day++;
                    this.endOfDay(); // í•˜ë£¨ê°€ ëë‚  ë•Œ í˜¸ì¶œ
                }
                
                this.gameState.isNight = currentHour >= 18 || currentHour < 6;

                // ì˜¤ì „ 6ì‹œê°€ ë˜ë©´ startOfDay í˜¸ì¶œ (ë‹¨, 5ì‹œì—ì„œ 6ì‹œë¡œ ë„˜ì–´ê°€ëŠ” ìˆœê°„ì—ë§Œ)
                if (currentHour === 6 && prevHour === 5) {
                    this.startOfDay(); // í•˜ë£¨ê°€ ì‹œì‘ë  ë•Œ í˜¸ì¶œ
                }
            }
            
            // í•˜ë£¨ ì‹œì‘ ì‹œ ì²˜ë¦¬
            startOfDay() {
                // Prevent multiple calls within the same game day
                if (this._lastStartedDay === this.gameState.day) {
                    return;
                }
                this._lastStartedDay = this.gameState.day;

                this.entities = this.entities.filter(e => !(e instanceof Wolf)); // ëŠ‘ëŒ€ ì œê±°
                this.world.pasture.gate.isOpen = true; // ì•„ì¹¨ì—ëŠ” ë¬¸ í•­ìƒ ì—´ë¦¼
                this.logMessage(`ìƒˆë¡œìš´ ë‚ ì´ ë°ì•˜ìŠµë‹ˆë‹¤. Day ${this.gameState.day}`);

                // [ìˆ˜ì •] í’€ ì¬ìƒì„± ë° ì„±ì¥ ë¡œì§
                // 1. ì¬ìƒì„± ë¡œì§ (ë§¤ì¼ ì‹¤í–‰)
                this.world.grassPatches.forEach(p => {
                    p.tiles.forEach(row => row.forEach(tile => {
                        // 5í„´ í›„ì— 0ì—ì„œ 1ë¡œ ì¬ìƒì„±
                        if (tile.richness === 0 && tile.regrowthTimer > 0) {
                            tile.regrowthTimer--;
                            if (tile.regrowthTimer === 0) {
                                tile.richness = 1;
                            }
                        }
                    }));
                });

                // 2. ì„±ì¥ ë¡œì§ (2í„´ë§ˆë‹¤ ì‹¤í–‰)
                if (this.gameState.day % 2 === 0) {
                    this.world.grassPatches.forEach(p => {
                        p.tiles.forEach(row => row.forEach(tile => {
                            if (tile.richness > 0 && tile.richness < tile.maxRichness) {
                                tile.richness++;
                            }
                        }));
                    });
                }
                
                this.handleBreedingAndGrowth();
            }

            // í•˜ë£¨ ì¢…ë£Œ ì‹œ ì²˜ë¦¬
            endOfDay() {
                // Prevent multiple calls within the same game day
                if (this._lastEndedDay === this.gameState.day) {
                    return;
                }
                this._lastEndedDay = this.gameState.day;

                this.entities.forEach(e => { if (e.endOfDay) e.endOfDay(); });
            }

            // ë²ˆì‹ ë° ì„±ì¥
            handleBreedingAndGrowth() {
                const adultSheepInPasture = this.entities.filter(e => e instanceof Sheep && e.isAdult && !e.breedingCooldown && this.isInsidePasture(e));
                let breedingPairs = Math.floor(adultSheepInPasture.length / 2);
                for(let i = 0; i < breedingPairs; i++) {
                    this.entities.push(new Sheep(this, this.world.pasture.x + this.world.pasture.width/2, this.world.pasture.y + this.world.pasture.height/2, false));
                    adultSheepInPasture[i*2].breedingCooldown = 5;
                    adultSheepInPasture[i*2+1].breedingCooldown = 5;
                }
            }

            // ëŠ‘ëŒ€ ìŠ¤í°
            spawnWolves() {
                if (this.gameState.isNight && this.gameState.time >= config.WOLF_SPAWN_TIME) {
                    if (Math.random() < 0.001 * this.gameState.day) {
                        const side = Math.floor(Math.random() * 4);
                        let x, y;
                        if (side === 0) { x = 0; y = Math.random() * this.world.height; }
                        else if (side === 1) { x = this.world.width; y = Math.random() * this.world.height; }
                        else if (side === 2) { x = Math.random() * this.world.width; y = 0; }
                        else { x = Math.random() * this.world.width; y = this.world.height; }
                        this.entities.push(new Wolf(this, x, y));
                    }
                }
            }
            
            // ê±´ì´ˆ ì˜®ê¸°ê¸°
            transferHay(direction, quantity) {
                const trough = this.world.pasture.trough;
                if (direction === 'toTrough') {
                    const tiles = trough.troughTiles;
                    const before = this.calculateTroughHayAmount();
                    let remaining = Math.min(
                        quantity,
                        this.gameState.hayStock
                    );
                    // ë¼ìš´ë“œë¡œë¹ˆ 1ê°œì”© ë¶„ë°°
                    while (remaining > 0) {
                        let movedThisRound = 0;
                        for (let i = 0; i < tiles.length && remaining > 0; i++) {
                            const tile = tiles[i];
                            if (tile.richness < tile.maxRichness) {
                                tile.richness += 1;
                                this.gameState.hayStock -= 1;
                                remaining -= 1;
                                movedThisRound++;
                            }
                        }
                        if (movedThisRound === 0) break; // ëª¨ë‘ ê°€ë“ ì°¸
                    }
                    trough.hayAmount = this.calculateTroughHayAmount();
                    const transferred = trough.hayAmount - before;
                    this.logMessage(`ê±´ì´ˆ ${transferred}ê°œë¥¼ ë¨¹ì´í†µì— ë„£ì—ˆìŠµë‹ˆë‹¤. (ë‚¨ì€ ê±´ì´ˆ: ${this.gameState.hayStock})`);
                } else if (direction === 'fromTrough') {
                    let amountToTransfer = quantity;
                    for (let i = 0; i < trough.troughTiles.length && amountToTransfer > 0; i++) {
                        const tile = trough.troughTiles[i];
                        const transferFromTile = Math.min(amountToTransfer, tile.richness);
                        if (transferFromTile > 0) {
                            tile.richness -= transferFromTile;
                            this.gameState.hayStock += transferFromTile;
                            amountToTransfer -= transferFromTile;
                        }
                    }
                    this.world.pasture.trough.hayAmount = this.calculateTroughHayAmount(); // Update total
                    this.logMessage(`ê±´ì´ˆ ${quantity - amountToTransfer}ê°œë¥¼ ë¨¹ì´í†µì—ì„œ ì°½ê³ ë¡œ ì˜®ê²¼ìŠµë‹ˆë‹¤. (ì´ ê±´ì´ˆ: ${this.gameState.hayStock})`);
                }
            }

            // ë¦¬ë” ì–‘ ì—…ë°ì´íŠ¸
            updateLeaderSheep() {
                if (this.leaderSheep && !this.leaderSheep.isDead) return;

                if (this.leaderSheep) {
                    this.leaderSheep.isLeader = false; // Fix: Assign false to isLeader property
                    this.leaderSheep = null;
                }

                const adultSheep = this.entities.filter(e => e instanceof Sheep && e.isAdult).sort((a, b) => a.age - b.age);
                if (adultSheep.length > 0) {
                    this.leaderSheep = adultSheep[0];
                    this.leaderSheep.isLeader = true;
                }
            }

            // ì¹´ë©”ë¼ ì—…ë°ì´íŠ¸
            updateCamera() {
                this.camera.x = this.shepherd.x - this.canvas.width / 2;
                this.camera.y = this.shepherd.y - this.canvas.height / 2;
                this.camera.x = Math.max(0, Math.min(this.camera.x, this.world.width - this.canvas.width));
                this.camera.y = Math.max(0, Math.min(this.camera.y, this.world.height - this.canvas.height));
            }
            
            // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ
            resizeCanvas() {
                const container = document.getElementById('game-container');
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }

            // ê²Œì„ ì˜¤ë²„ í™•ì¸
            checkGameOver() {
                if (this.shepherd.hp <= 0 || (this.entities.filter(e => e instanceof Sheep).length === 0 && this.gameState.day > 1)) {
                    this.gameState.gameOver = true;
                    this.ui.showGameOverModal();
                    this.logMessage(`ê²Œì„ ì˜¤ë²„! ${this.gameState.day}ì¼ ìƒì¡´í–ˆìŠµë‹ˆë‹¤.`);
                }
            }

            // ëª©ì¥ ì•ˆì— ìˆëŠ”ì§€ í™•ì¸
            isInsidePasture(entity) {
                const p = this.world.pasture;
                return entity.x > p.x && entity.x < p.x + p.width && entity.y > p.y && entity.y < p.y + p.height;
            }

            // ê²Œì„ ë¡œê·¸ ë©”ì‹œì§€ ì¶”ê°€
            logMessage(message) {
                const p = document.createElement('p');
                p.textContent = `[${this.ui.getFormattedTime()}] ${message}`;
                this.logDisplay.appendChild(p);
                this.logDisplay.scrollTop = this.logDisplay.scrollHeight; // ìŠ¤í¬ë¡¤ì„ ë§¨ ì•„ë˜ë¡œ
            }
        }

        class Character {
            constructor(game, x, y, radius, color) {
                this.game = game; this.x = x; this.y = y; this.radius = radius; this.color = color;
                this.hp = 100; this.maxHp = 100; this.speed = 1; this.target = null; this.isDead = false;
                this.name = '';
                this.deathLogged = false; // ì‚¬ë§ ë¡œê·¸ ê¸°ë¡ ì—¬ë¶€ í”Œë˜ê·¸
            }
            update(deltaTime) {
                if (this.hp <= 0 && !this.isDead) { // ìºë¦­í„°ê°€ ì£½ì—ˆì„ ë•Œ
                    this.isDead = true;
                    if (!this.deathLogged) { // ì•„ì§ ì‚¬ë§ ë¡œê·¸ê°€ ê¸°ë¡ë˜ì§€ ì•Šì•˜ë‹¤ë©´
                        // ë¡œê·¸ ë©”ì‹œì§€ëŠ” ê° ì„œë¸Œí´ë˜ìŠ¤ì—ì„œ ë” êµ¬ì²´ì ìœ¼ë¡œ ì²˜ë¦¬
                        this.deathLogged = true;
                    }
                }
                this.resolveCollisions();
                if (!this.game.gameState.isNight && this.hp < this.maxHp && !this.isDead) { // ë‚®ì— ì²´ë ¥ íšŒë³µ (ì£½ì§€ ì•Šì•˜ì„ ë•Œë§Œ)
                    this.hp += 0.01;
                }
            }
            draw(ctx) {
                ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
                
                let barY = this.y - this.radius - 12;
                if (this.name) {
                    ctx.fillStyle = 'rgba(0,0,0,0.7)';
                    ctx.textAlign = 'center';
                    ctx.font = '10px sans-serif';
                    ctx.fillText(this.name, this.x, barY - 2);
                    barY -= 12;
                }

                if (this.hp < this.maxHp) {
                    ctx.fillStyle = '#555'; ctx.fillRect(this.x - this.radius, barY, this.radius * 2, 5);
                    const hpColor = this.hp > this.maxHp * 0.5 ? '#2ecc71' : (this.hp > this.maxHp * 0.25 ? '#f1c40f' : '#e74c3c');
                    ctx.fillStyle = hpColor; ctx.fillRect(this.x - this.radius, barY, this.radius * 2 * (this.hp / this.maxHp), 5);
                }
            }
            applyMovement(dx, dy) {
                this.x += dx;
                this.y += dy;
            }
            resolveCollisions() {
                // Entity-Entity Collision (ì—”í‹°í‹° ê°„ ì¶©ëŒ)
                this.game.entities.forEach(other => {
                    if (this === other || other.isDead) return;
                    const dist = utils.distance(this, other);
                    const minDist = this.radius + other.radius;
                    if (dist < minDist) {
                        const overlap = minDist - dist;
                        const angle = Math.atan2(this.y - other.y, this.x - other.x);
                        const pushX = Math.cos(angle) * overlap * 0.5;
                        const pushY = Math.sin(angle) * overlap * 0.5;
                        this.x += pushX; this.y += pushY;
                        other.x -= pushX; other.y -= pushY;
                    }
                });

                // World boundary (ì›”ë“œ ê²½ê³„)
                this.x = Math.max(this.radius, Math.min(this.x, this.game.world.width - this.radius));
                this.y = Math.max(this.radius, Math.min(this.y, this.game.world.height - this.radius));

                // Fence Collision (ìš¸íƒ€ë¦¬ ì¶©ëŒ)
                const p = this.game.world.pasture;
                const g = p.gate;
                const isInside = this.x > p.x && this.x < p.x + p.width && this.y > p.y && this.y < p.y + p.height;
                
                if (isInside) {
                    if (this.x - this.radius < p.x) this.x = p.x + this.radius;
                    if (this.x + this.radius > p.x + p.width) this.x = p.x + p.width - this.radius;
                    if (this.y - this.radius < p.y) this.y = p.y + this.radius;
                    // Bottom fence with gate (ë¬¸ì´ ìˆëŠ” ì•„ë˜ ìš¸íƒ€ë¦¬)
                    if (this.y + this.radius > p.y + p.height) {
                        const inGateX = this.x > g.x && this.x < g.x + g.width;
                        if (!g.isOpen || !inGateX) {
                            this.y = p.y + p.height - this.radius;
                        }
                    }
                } else {
                    const charBox = { left: this.x - this.radius, right: this.x + this.radius, top: this.y - this.radius, bottom: this.y + this.radius };
                    const fenceBox = { left: p.x, right: p.x + p.width, top: p.y, bottom: p.y + p.height };
                    if (charBox.right > fenceBox.left && charBox.left < fenceBox.right && charBox.bottom > fenceBox.top && charBox.top < fenceBox.bottom) {
                        // Trying to enter from outside (ë°–ì—ì„œ ì•ˆìœ¼ë¡œ ì§„ì… ì‹œë„)
                        const inGateX = this.x > g.x && this.x < g.x + g.width;
                        const atGateY = Math.abs(this.y - (p.y + p.height)) < this.radius;
                        if (g.isOpen && inGateX && atGateY) {
                            // Allow pass (í†µê³¼ í—ˆìš©)
                        } else {
                            // Push out (ë°–ìœ¼ë¡œ ë°€ì–´ë‚´ê¸°)
                            const dx = (this.x - (p.x + p.width / 2));
                            const dy = (this.y - (p.y + p.height / 2));
                            const overlapX = (this.radius + p.width / 2) - Math.abs(dx);
                            const overlapY = (this.radius + p.height / 2) - Math.abs(dy);
                            if (overlapX < overlapY) {
                                this.x += (dx > 0 ? overlapX : -overlapX);
                            } else {
                                this.y += (dy > 0 ? overlapY : -overlapY);
                            }
                        }
                    }
                }
            }
            moveTowards(target, speed) {
                const angle = Math.atan2(target.y - this.y, target.x - this.x);
                const dx = Math.cos(angle) * speed; const dy = Math.sin(angle) * speed;
                this.applyMovement(dx, dy);
            }
        }

        class Shepherd extends Character {
            constructor(game, x, y) { 
                super(game, x, y, 15, '#3498db'); 
                this.speed = config.SHEPHERD_SPEED; 
                this.name = 'ì–‘ì¹˜ê¸°'; // ì–‘ì¹˜ê¸° ì´ë¦„ ì„¤ì •
            }
            update(deltaTime) {
                const dxInput = this.game.input.moveX; // InputHandlerì—ì„œ ê°€ì ¸ì˜¨ x ë°©í–¥ ì…ë ¥
                const dyInput = this.game.input.moveY; // InputHandlerì—ì„œ ê°€ì ¸ì˜¨ y ë°©í–¥ ì…ë ¥
                
                // console.log(`Shepherd.update: dxInput=${dxInput}, dyInput=${dyInput}`); // ë””ë²„ê¹… ë¡œê·¸ ì¶”ê°€

                if (dxInput !== 0 || dyInput !== 0) {
                    const magnitude = Math.sqrt(dxInput * dxInput + dyInput * dyInput);
                    const dx = (dxInput / magnitude) * this.speed; 
                    const dy = (dyInput / magnitude) * this.speed;
                    this.applyMovement(dx, dy);
                }
                super.update(deltaTime);
            }
        }
        
        class Sheep extends Character {
            constructor(game, x, y, isAdult) {
                super(game, x, y, isAdult ? 12 : 8, 'white');
                this.speed = config.SHEEP_SPEED;
                this.hunger = 100;
                this.isAdult = isAdult;
                this.age = isAdult ? 7 : 0;
                this.breedingCooldown = 0;
                this.state = 'wandering';
                this.stateTimer = 0;
                this.maxHp = 50;
                this.hp = 50;
                this.vx = 0;
                this.vy = 0; // Velocity for smooth movement
                this.isLeader = false;
                this.name = `ì–‘ #${Math.floor(Math.random() * 1000)}`;
                this.perceptionRange = 100; // ì´ ì‹œì•¼ ê±°ë¦¬
                this.eatingTimer = 0; // ë¨¹ì´ ì„­ì·¨ ë”œë ˆì´ íƒ€ì´ë¨¸ (í’€, ê±´ì´ˆ ê³µìš©)
            }

            update(deltaTime) {
                // --- ê¸°ë³¸ ìƒíƒœ ì—…ë°ì´íŠ¸ ---
                this.stateTimer -= 1;
                this.hunger -= 0.01;
                if (this.hunger <= 0) {
                    this.hp -= 0.02;
                    this.hunger = 0;
                    if (this.hp <= 0 && !this.isDead && !this.deathLogged) {
                        this.game.logMessage(`${this.name}ì´(ê°€) êµ¶ì£¼ë¦¼ìœ¼ë¡œ ì£½ì—ˆìŠµë‹ˆë‹¤.`);
                        this.deathLogged = true;
                    }
                }

                // --- ì£¼ë³€ í™˜ê²½ ê°ì§€ ---
                const dangers = this.game.entities.filter(e => 
                    (e instanceof Wolf && utils.distance(this, e) < 200) ||
                    ((e instanceof Shepherd || e instanceof Dog) && utils.distance(this, e) < 100)
                );
                const inPasture = this.game.isInsidePasture(this);
                const currentFoodSource = this.getCurrentFoodSource();

                // --- í–‰ë™ ê²°ì • (State Machine) ---
                // ìš°ì„ ìˆœìœ„ 1: ìœ„í—˜ ê°ì§€ (ë„ë§)
                if (dangers.length > 0) {
                    this.state = 'fleeing';
                }
                // ìš°ì„ ìˆœìœ„ 2: ë¨¹ì´ í™œë™ (ìœ„í—˜ì´ ì—†ê³ , ë¨¹ì´ ìœ„ì— ìˆìœ¼ë©°, ë°°ë¶€ë¥´ì§€ ì•Šì„ ë•Œ)
                else if (currentFoodSource && this.hunger < 95) {
                    this.state = 'eating';
                }
                // ìš°ì„ ìˆœìœ„ 3: ë°°ê³ í”” (ë¨¹ì´ ì°¾ê¸°)
                else if (this.hunger <= 50) {
                    this.state = 'seeking_food';
                }
                // ìš°ì„ ìˆœìœ„ 4: ë¬´ë¦¬ í–‰ë™ (ë”°ë¼ê°€ê¸°)
                else {
                    // ìƒˆë¼ ì–‘ì€ ì–´ë¥¸ ì–‘ì„ ë”°ë¼ê°
                    if (!this.isAdult && this.findClosest(Sheep, this.perceptionRange, s => s.isAdult)) {
                        this.state = 'following_adult';
                    }
                    // ë¦¬ë”ê°€ ì•„ë‹Œ ì–‘ì€ ë¦¬ë”ë¥¼ ë”°ë¼ê°
                    else if (!this.isLeader && this.game.leaderSheep && this.game.leaderSheep !== this) {
                        this.state = 'following_leader';
                    }
                    // ê·¸ ì™¸ì—ëŠ” ë°°íšŒ
                    else {
                        this.state = 'wandering';
                    }
                }

                // --- ìƒíƒœì— ë”°ë¥¸ í–‰ë™ ì‹¤í–‰ ë° ì´ë™ ë²¡í„° ê³„ì‚° ---
                let finalDx = 0, finalDy = 0;
                let isMoving = true;

                switch (this.state) {
                    case 'fleeing':
                        let avgX = 0, avgY = 0;
                        dangers.forEach(d => { avgX += d.x; avgY += d.y; });
                        avgX /= dangers.length;
                        avgY /= dangers.length;
                        const fleeAngle = Math.atan2(this.y - avgY, this.x - avgX);
                        finalDx = Math.cos(fleeAngle);
                        finalDy = Math.sin(fleeAngle);
                        break;

                    case 'eating':
                        isMoving = false; // ë¨¹ëŠ” ë™ì•ˆì€ ë©ˆì¶¤
                        this.eatingTimer -= deltaTime;
                        if (this.eatingTimer <= 0) {
                            if (currentFoodSource.type === 'grass') {
                                this.hunger = Math.min(100, this.hunger + 10);
                                currentFoodSource.tileObject.richness--;
                                this.game.logMessage(`${this.name}ì´(ê°€) í’€ì„ ë¨¹ì–´ ë°°ë¶€ë¦„ì´ 10 ì˜¬ëìŠµë‹ˆë‹¤.`);
                                // [ìˆ˜ì •] í’€ì„ ë‹¤ ë¨¹ìœ¼ë©´ ì¬ìƒì„± íƒ€ì´ë¨¸ ì‹œì‘
                                if (currentFoodSource.tileObject.richness <= 0) {
                                    currentFoodSource.tileObject.regrowthTimer = 5; // 5í„´ í›„ ì¬ìƒì„± ì‹œì‘
                                }
                            } else if (currentFoodSource.type === 'hay') {
                                this.hunger = Math.min(100, this.hunger + 30);
                                currentFoodSource.tileObject.richness--;
                                this.game.world.pasture.trough.hayAmount = this.game.calculateTroughHayAmount();
                                this.game.logMessage(`${this.name}ì´(ê°€) ê±´ì´ˆë¥¼ ë¨¹ì–´ ë°°ë¶€ë¦„ì´ 30 ì˜¬ëìŠµë‹ˆë‹¤.`);
                            }
                            this.eatingTimer = config.GRASS_EATING_DELAY; // ë‹¤ìŒ ì„­ì·¨ ë”œë ˆì´
                        }
                        break;

                    case 'seeking_food':
                        const foodTarget = this.findClosestFood();
                        if (foodTarget) {
                            this.target = foodTarget;
                            const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                            finalDx = Math.cos(angle);
                            finalDy = Math.sin(angle);
                        } else {
                            // ë¨¹ì´ë¥¼ ëª» ì°¾ìœ¼ë©´ ë°°íšŒ ìƒíƒœë¡œ ì „í™˜
                            this.state = 'wandering';
                        }
                        break;

                    case 'following_leader':
                        const leader = this.game.leaderSheep;
                        if (leader && utils.distance(this, leader) > 50) { // 50 ê±°ë¦¬ ìœ ì§€
                            const angle = Math.atan2(leader.y - this.y, leader.x - this.x);
                            finalDx = Math.cos(angle);
                            finalDy = Math.sin(angle);
                        }
                        // ë¬´ë¦¬ ìœ ì§€ ë¡œì§ ì¶”ê°€
                        const cohesion_leader = this.calculateCohesionVector(30); // 30 ê±°ë¦¬ ìœ ì§€
                        finalDx += cohesion_leader.dx * 0.5;
                        finalDy += cohesion_leader.dy * 0.5;
                        break;

                    case 'following_adult':
                        const adult = this.findClosest(Sheep, this.perceptionRange, s => s.isAdult);
                        if (adult && utils.distance(this, adult) > 50) { // 50 ê±°ë¦¬ ìœ ì§€
                            const angle = Math.atan2(adult.y - this.y, adult.x - this.x);
                            finalDx = Math.cos(angle);
                            finalDy = Math.sin(angle);
                        }
                        // ë¬´ë¦¬ ìœ ì§€ ë¡œì§ ì¶”ê°€
                        const cohesion_adult = this.calculateCohesionVector(30); // 30 ê±°ë¦¬ ìœ ì§€
                        finalDx += cohesion_adult.dx * 0.5;
                        finalDy += cohesion_adult.dy * 0.5;
                        break;

                    case 'wandering':
                        if (this.stateTimer <= 0 || !this.target || utils.distance(this, this.target) < 10) {
                            this.target = { x: this.x + (Math.random() - 0.5) * 200, y: this.y + (Math.random() - 0.5) * 200 };
                            this.stateTimer = Math.random() * 300 + 200;
                        }
                        if (this.target) {
                            const angle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                            finalDx = Math.cos(angle);
                            finalDy = Math.sin(angle);
                        }
                        // ë¬´ë¦¬ ìœ ì§€ ë¡œì§ ì¶”ê°€
                        const cohesion_wander = this.calculateCohesionVector(30); // 30 ê±°ë¦¬ ìœ ì§€
                        finalDx += cohesion_wander.dx * 0.8; // ë°°íšŒ ì‹œì—ëŠ” ë¬´ë¦¬ ìœ ì§€ë¥¼ ë” ì¤‘ìš”í•˜ê²Œ
                        finalDy += cohesion_wander.dy * 0.8;
                        break;
                }

                // --- ìµœì¢… ì´ë™ ì ìš© ---
                let desiredVx = 0, desiredVy = 0;
                const magnitude = Math.sqrt(finalDx * finalDx + finalDy * finalDy);
                if (magnitude > 0) {
                    let currentSpeed = this.speed;
                    if (this.state === 'fleeing') currentSpeed *= 1.5;
                    else if (this.state === 'wandering') currentSpeed *= 0.7;
                    desiredVx = (finalDx / magnitude) * currentSpeed;
                    desiredVy = (finalDy / magnitude) * currentSpeed;
                }

                if (isMoving) {
                    const steeringFactor = 0.05;
                    this.vx = this.vx * (1 - steeringFactor) + desiredVx * steeringFactor;
                    this.vy = this.vy * (1 - steeringFactor) + desiredVy * steeringFactor;
                } else {
                    this.vx *= 0.8; // ë©ˆì¶œ ë•Œ ë¶€ë“œëŸ½ê²Œ ê°ì†
                    this.vy *= 0.8;
                }

                if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) {
                    this.applyMovement(this.vx, this.vy);
                }
                super.update(deltaTime);
            }

            // ì£¼ë³€ì˜ ë‹¤ë¥¸ ì–‘ë“¤ê³¼ì˜ ê±°ë¦¬ë¥¼ 30 ì´ë‚´ë¡œ ìœ ì§€í•˜ë ¤ëŠ” í˜ ê³„ì‚°
            calculateCohesionVector(flockDistance) {
                let avgX = 0, avgY = 0;
                let separationDx = 0, separationDy = 0;
                let count = 0;
                const flockmates = this.game.entities.filter(e => e instanceof Sheep && e !== this && utils.distance(this, e) < this.perceptionRange);

                if (flockmates.length > 0) {
                    flockmates.forEach(fm => {
                        const dist = utils.distance(this, fm);
                        if (dist < flockDistance) { // ë„ˆë¬´ ê°€ê¹Œìš°ë©´ ë°€ì–´ëƒ„ (separation)
                            const angle = Math.atan2(this.y - fm.y, this.x - fm.x);
                            separationDx += Math.cos(angle);
                            separationDy += Math.sin(angle);
                        }
                        avgX += fm.x;
                        avgY += fm.y;
                        count++;
                    });

                    if (count > 0) {
                        avgX /= count;
                        avgY /= count;
                        const angleToCenter = Math.atan2(avgY - this.y, avgX - this.x);
                        // ìµœì¢… ë²¡í„°ëŠ” ë¬´ë¦¬ ì¤‘ì‹¬ìœ¼ë¡œ í–¥í•˜ëŠ” í˜ê³¼ ë„ˆë¬´ ê°€ê¹Œìš´ ì–‘ì„ ë°€ì–´ë‚´ëŠ” í˜ì˜ í•©
                        return {
                            dx: Math.cos(angleToCenter) + separationDx,
                            dy: Math.sin(angleToCenter) + separationDy
                        };
                    }
                }
                return { dx: 0, dy: 0 };
            }

            // í˜„ì¬ ìœ„ì¹˜ì˜ ë¨¹ì´ ì •ë³´ ë°˜í™˜ (í’€ ë˜ëŠ” ê±´ì´ˆ)
            getCurrentFoodSource() {
                // ìš¸íƒ€ë¦¬ ì•ˆ: ë¨¹ì´í†µ í™•ì¸
                if (this.game.isInsidePasture(this)) {
                    const trough = this.game.world.pasture.trough;
                    const troughTileWidth = trough.width / trough.numTroughTiles;
                    if (this.x >= trough.x && this.x <= trough.x + trough.width &&
                        this.y >= trough.y && this.y <= trough.y + trough.height) {
                        const tileIndex = Math.floor((this.x - trough.x) / troughTileWidth);
                        const tile = trough.troughTiles[tileIndex];
                        if (tile && tile.richness > 0) {
                            return { type: 'hay', tileObject: tile };
                        }
                    }
                }
                // ìš¸íƒ€ë¦¬ ë°–: í’€ í™•ì¸
                else {
                    for (const patch of this.game.world.grassPatches) {
                        if (this.x > patch.x && this.x < patch.x + patch.width && this.y > patch.y && this.y < patch.y + patch.height) {
                            const c = Math.floor((this.x - patch.x) / config.GRASS_TILE_SIZE);
                            const r = Math.floor((this.y - patch.y) / config.GRASS_TILE_SIZE);
                            if (patch.tiles[r] && patch.tiles[r][c] && patch.tiles[r][c].richness > 0) {
                                return { type: 'grass', tileObject: patch.tiles[r][c] };
                            }
                        }
                    }
                }
                return null;
            }

            // ê°€ì¥ ê°€ê¹Œìš´ ìœ íš¨í•œ ë¨¹ì´ ìœ„ì¹˜ ì°¾ê¸°
            findClosestFood() {
                // ìš¸íƒ€ë¦¬ ì•ˆì—ì„œëŠ” ë¨¹ì´í†µë§Œ ì°¾ìŒ
                if (this.game.isInsidePasture(this)) {
                    const trough = this.game.world.pasture.trough;
                    let closestHayTile = null;
                    let minDistToHayTile = Infinity;
                    trough.troughTiles.forEach((tile, index) => {
                        if (tile.richness > 0) {
                            const tileCenter = {
                                x: trough.x + index * (trough.width / trough.numTroughTiles) + (trough.width / trough.numTroughTiles) / 2,
                                y: trough.y + trough.height / 2
                            };
                            const dist = utils.distance(this, tileCenter);
                            if (dist < minDistToHayTile) {
                                minDistToHayTile = dist;
                                closestHayTile = tileCenter;
                            }
                        }
                    });
                    return closestHayTile;
                }
                // ìš¸íƒ€ë¦¬ ë°–ì—ì„œëŠ” í’€ë§Œ ì°¾ìŒ
                else {
                    let closestGrass = null;
                    let min_dist = this.perceptionRange;
                    this.game.world.grassPatches.forEach(p => {
                        for (let r = 0; r < p.tiles.length; r++) {
                            for (let c = 0; c < p.tiles[r].length; c++) {
                                if (p.tiles[r][c].richness > 0) {
                                    const tilePos = { x: p.x + (c + 0.5) * config.GRASS_TILE_SIZE, y: p.y + (r + 0.5) * config.GRASS_TILE_SIZE };
                                    const d = utils.distance(this, tilePos);
                                    if (d < min_dist) {
                                        min_dist = d;
                                        closestGrass = tilePos;
                                    }
                                }
                            }
                        }
                    });
                    return closestGrass;
                }
            }
            
            draw(ctx) {
                super.draw(ctx);
                if (this.isLeader) {
                    ctx.fillStyle = 'gold';
                    ctx.font = '16px sans-serif';
                    ctx.fillText('ğŸ‘‘', this.x, this.y - this.radius - (this.name ? 25 : 15) - (this.hp < this.maxHp ? 12 : 0));
                }
                if (this.hunger < 100) {
                    ctx.fillStyle = '#7a5c58'; ctx.fillRect(this.x - this.radius, this.y + this.radius + 2, this.radius * 2, 4);
                    ctx.fillStyle = '#cdab7d'; ctx.fillRect(this.x - this.radius, this.y + this.radius + 2, this.radius * 2 * (this.hunger / 100), 4);
                }
            }

            findClosest(type, range, filter = () => true) {
                let closest = null, min_dist = range;
                this.game.entities.forEach(e => {
                    if (e instanceof type && e !== this && filter(e)) { const d = utils.distance(this, e);
                        if (d < min_dist) { min_dist = d; closest = e; }
                    }
                });
                return closest;
            }
            endOfDay() {
                this.age++;
                if (!this.isAdult && this.age >= 7) { this.isAdult = true; this.radius = 12; }
                if (this.breedingCooldown > 0) this.breedingCooldown--;
            }
        }

        class Dog extends Character {
            constructor(game, x, y) {
                super(game, x, y, 13, '#a0522d'); 
                this.speed = config.DOG_SPEED; 
                this.command = 'follow';
                this.maxHp = 150; 
                this.hp = 150;
                this.name = `ê°œ #${Math.floor(Math.random() * 1000)}`;
                this.id = ++game.idCounters.dog;
            }
            update(deltaTime) {
                const wolf = this.findClosest(Wolf, 200);
                if (wolf) {
                    this.target = wolf; this.moveTowards(this.target, this.speed);
                    if (utils.distance(this, this.target) < this.radius + this.target.radius) {
                        wolf.hp -= 0.5; // ê°œê°€ ëŠ‘ëŒ€ ê³µê²©
                        if (wolf.hp <= 0 && !wolf.isDead && !wolf.deathLogged) { // ëŠ‘ëŒ€ê°€ ì´ ê³µê²©ìœ¼ë¡œ ì£½ì—ˆë‹¤ë©´
                            this.game.logMessage(`${this.name}ì´(ê°€) ëŠ‘ëŒ€ ${wolf.name || ''}ë¥¼ ì²˜ì¹˜í–ˆìŠµë‹ˆë‹¤.`);
                            wolf.deathLogged = true; // ëŠ‘ëŒ€ì˜ ì‚¬ë§ ë¡œê·¸ ê¸°ë¡ í”Œë˜ê·¸ ì„¤ì •
                        }
                    }
                } else {
                    if (this.command === 'follow' && utils.distance(this, this.game.shepherd) > 50) {
                        this.moveTowards(this.game.shepherd, this.speed);
                    }
                }
                super.update(deltaTime);
            }
            findClosest(type, range) {
                let closest = null, min_dist = range;
                this.game.entities.forEach(e => {
                    if (e instanceof type && !e.isDead) { const d = utils.distance(this, e);
                        if (d < min_dist) { min_dist = d; closest = e; }
                    }
                });
                return closest;
            }
        }
        
        class Wolf extends Character {
            constructor(game, x, y) {
                super(game, x, y, 16, '#555'); 
                this.speed = config.WOLF_SPEED; 
                this.maxHp = 100; 
                this.hp = 100;
                this._skinDropped = false; // ëŠ‘ëŒ€ ê°€ì£½ ë“œë¡­ ì—¬ë¶€ í”Œë˜ê·¸
                this.name = `ëŠ‘ëŒ€ #${Math.floor(Math.random() * 1000)}`; // ëŠ‘ëŒ€ ì´ë¦„ ì„¤ì •
            }
            update(deltaTime) {
                // ì´ë¯¸ ì£½ì€ ëŠ‘ëŒ€ëŠ” ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŒ
                if (this.isDead) {
                    return;
                }

                // ì²´ë ¥ì´ 0 ì´í•˜ê°€ ë˜ë©´ ëŠ‘ëŒ€ ê°€ì£½ ë“œë¡­
                if (this.hp <= 0 && !this._skinDropped) {
                    this.game.gameState.wolfSkin++;
                    this.game.logMessage(`ëŠ‘ëŒ€ ${this.name || ''}ê°€ ì£½ê³  ëŠ‘ëŒ€ ê°€ì£½ì„ íšë“í–ˆìŠµë‹ˆë‹¤. (ì´ ${this.game.gameState.wolfSkin}ê°œ)`);
                    this._skinDropped = true;
                    this.isDead = true; // ì£½ìŒ ìƒíƒœë¡œ ì„¤ì •
                    this.deathLogged = true; // ì‚¬ë§ ë¡œê·¸ ê¸°ë¡ í”Œë˜ê·¸ ì„¤ì •
                    return; // ë” ì´ìƒ ì—…ë°ì´íŠ¸í•˜ì§€ ì•ŠìŒ
                }

                if (!this.target || this.target.isDead) {
                    this.target = this.findTarget();
                }

                if (this.target) {
                    this.moveTowards(this.target, this.speed);
                    if (utils.distance(this, this.target) < this.radius + this.target.radius) {
                        this.target.hp -= 1; // íƒ€ê²Ÿ ê³µê²©
                        if (this.target.hp <= 0 && !this.target.isDead && !this.target.deathLogged) { // íƒ€ê²Ÿì´ ì´ ê³µê²©ìœ¼ë¡œ ì£½ì—ˆë‹¤ë©´
                            if (this.target instanceof Sheep) {
                                this.game.logMessage(`ëŠ‘ëŒ€ ${this.name || ''}ì´(ê°€) ${this.target.name}ì„(ë¥¼) ê³µê²©í•˜ì—¬ ì£½ì˜€ìŠµë‹ˆë‹¤.`);
                                this.target.deathLogged = true; // íƒ€ê²Ÿì˜ ì‚¬ë§ ë¡œê·¸ ê¸°ë¡ í”Œë˜ê·¸ ì„¤ì •
                                this.target.hp = 0; // ì–‘ì€ ë°”ë¡œ ì£½ìŒ
                            } else if (this.target instanceof Shepherd) {
                                this.game.logMessage(`ëŠ‘ëŒ€ ${this.name || ''}ì´(ê°€) ì–‘ì¹˜ê¸° ${this.target.name || ''}ë¥¼ ê³µê²©í•˜ì—¬ ì£½ì˜€ìŠµë‹ˆë‹¤.`);
                                this.target.deathLogged = true;
                            } else if (this.target instanceof Dog) {
                                this.game.logMessage(`ëŠ‘ëŒ€ ${this.name || ''}ì´(ê°€) ê°œ ${this.target.name || ''}ë¥¼ ê³µê²©í•˜ì—¬ ì£½ì˜€ìŠµë‹ˆë‹¤.`);
                                this.target.deathLogged = true;
                            }
                        }
                    }
                }
                super.update(deltaTime); // Characterì˜ updateë¥¼ í˜¸ì¶œí•˜ì—¬ ì²´ë ¥ ë° isDead ìƒíƒœ ê´€ë¦¬
            }
            findTarget() {
                let potentialTargets = this.game.entities.filter(e => (e instanceof Sheep || e instanceof Dog || e instanceof Shepherd) && !e.isDead);
                potentialTargets.sort((a,b) => utils.distance(this, a) - utils.distance(this, b));
                return potentialTargets[0] || null;
            }
        }
        
        class InputHandler {
            constructor(game) {
                this.game = game; this.keys = {}; this.moveX = 0; this.moveY = 0;
                // console.log("InputHandler initialized. Listening for keyboard/touch events."); // Debug log
                window.addEventListener('keydown', e => {
                    this.keys[e.key] = true;
                    // console.log("Key down:", e.key); // Debug log
                });
                window.addEventListener('keyup', e => {
                    this.keys[e.key] = false;
                    // console.log("Key up:", e.key); // Debug log
                });
                this.joystick = { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, maxDistance: 50 };
                if (utils.isMobile()) {
                    document.getElementById('joystick').classList.remove('hidden');
                    this.game.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this));
                    this.game.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this));
                    this.game.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this));
                }
                this.game.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
                // Removed this.update() from constructor - it's now called by Game.update()
            }
            update() {
                this.moveX = 0;
                this.moveY = 0;

                // Keyboard input
                if (this.keys['w'] || this.keys['W'] || this.keys['ArrowUp']) this.moveY -= 1;
                if (this.keys['s'] || this.keys['S'] || this.keys['ArrowDown']) this.moveY += 1;
                if (this.keys['a'] || this.keys['A'] || this.keys['ArrowLeft']) this.moveX -= 1;
                if (this.keys['d'] || this.keys['D'] || this.keys['ArrowRight']) this.moveX += 1;

                // Joystick input (overrides keyboard if active)
                if (this.joystick.active) {
                    const dx = this.joystick.currentX - this.joystick.startX;
                    const dy = this.joystick.currentY - this.joystick.startY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist > 0) {
                        this.moveX = dx / dist;
                        this.moveY = dy / dist;
                    } else {
                        this.moveX = 0;
                        this.moveY = 0;
                    }
                }
                // Debug log for movement input
                // if (this.moveX !== 0 || this.moveY !== 0) {
                //     console.log(`InputHandler: moveX=${this.moveX.toFixed(2)}, moveY=${this.moveY.toFixed(2)}`);
                // }
            }
            handleTouchStart(e) {
                const touch = e.touches[0]; const rect = this.game.canvas.getBoundingClientRect();
                const joystickBase = document.getElementById('joystick');
                joystickBase.style.left = `${touch.clientX - rect.left - 60}px`; joystickBase.style.top = `${touch.clientY - rect.top - 60}px`;
                this.joystick.active = true; this.joystick.startX = touch.clientX; this.joystick.startY = touch.clientY;
                this.joystick.currentX = touch.clientX; this.joystick.currentY = touch.clientY;
            }
            handleTouchMove(e) {
                if (!this.joystick.active) return; e.preventDefault();
                const touch = e.touches[0]; this.joystick.currentX = touch.clientX; this.joystick.currentY = touch.clientY;
                const dx = this.joystick.currentX - this.joystick.startX; const dy = this.joystick.currentY - this.joystick.startY;
                let dist = Math.sqrt(dx*dx + dy*dy);
                const handle = document.getElementById('joystick-handle');
                if (dist > this.joystick.maxDistance) handle.style.transform = `translate(${dx/dist * this.joystick.maxDistance}px, ${dy/dist * this.joystick.maxDistance}px)`;
                else handle.style.transform = `translate(${dx}px, ${dy}px)`;
            }
            handleTouchEnd(e) {
                this.joystick.active = false; this.moveX = 0; this.moveY = 0;
                document.getElementById('joystick-handle').style.transform = `translate(0px, 0px)`;
            }
            handleCanvasClick(e) {
                if (this.game.gameState.paused) return;
                const rect = this.game.canvas.getBoundingClientRect();
                const worldX = e.clientX - rect.left + this.game.camera.x;
                const worldY = e.clientY - rect.top + this.game.camera.y;

                // í´ë¦­ëœ ì—”í‹°í‹° í™•ì¸
                for (const entity of this.game.entities) {
                    if (entity instanceof Sheep && utils.distance({x: worldX, y: worldY}, entity) < entity.radius) {
                        this.game.ui.toggleSheepInfoModal(true, entity);
                        return; 
                    }
                    if (entity instanceof Dog && utils.distance({x: worldX, y: worldY}, entity) < entity.radius) {
                        this.game.ui.toggleDogInfoModal(true, entity);
                        return;
                    }
                }
            }
        }
        
        class UI {
            constructor(game) {
                this._dogStatusSnapshot = '';
                this.game = game;
                this.timeDisplay = document.getElementById('time-display'); 
                this.dayDisplay = document.getElementById('day-display');
                this.goldDisplay = document.getElementById('gold-display'); 
                this.sheepDisplay = document.getElementById('sheep-display');
                this.hayDisplay = document.getElementById('hay-display'); 
                this.wolfSkinDisplay = document.getElementById('wolf-skin-display'); // ëŠ‘ëŒ€ ê°€ì£½ HUD ìš”ì†Œ
                this.gateButton = document.getElementById('gate-button');
                this.marketButton = document.getElementById('market-button'); 
                this.hayActionButton = document.getElementById('hay-action-button');
                this.dogCommandAllButton = document.getElementById('dog-command-all-button'); 
                this.dogStatusUI = document.getElementById('dog-status-ui');

                // ìƒˆë¡œìš´ í™•ì¸ ëª¨ë‹¬ ìš”ì†Œë“¤
                this.confirmModal = document.getElementById('confirm-modal');
                this.confirmMessage = document.getElementById('confirm-message');
                this.confirmYesButton = document.getElementById('confirm-yes-button');
                this.confirmNoButton = document.getElementById('confirm-no-button');

                this.gateButton.addEventListener('click', () => {
                    const distToGate = utils.distance(this.game.shepherd, {x: this.game.world.pasture.gate.x + 40, y: this.game.world.pasture.gate.y + 10});
                    if (distToGate < 100) { // ì–‘ì¹˜ê¸°ê°€ ë¬¸ ê·¼ì²˜ì— ìˆì„ ë•Œë§Œ ì‘ë™
                        if (this.game.gameState.isNight && this.game.world.pasture.gate.isOpen) {
                            // ë°¤ì´ê³  ë¬¸ì´ ì—´ë ¤ìˆìœ¼ë©´, ì‹œê°„ ë„˜ê¸¸ì§€ ë¬¼ì–´ë´„
                            this.toggleConfirmModal(true, 'ë°¤ì´ ê¹Šì—ˆìŠµë‹ˆë‹¤. ì•„ì¹¨ìœ¼ë¡œ ì‹œê°„ì„ ë„˜ê¸°ì‹œê² ìŠµë‹ˆê¹Œ?', () => {
                                // ì˜ˆ (ì‹œê°„ ë„˜ê¸°ê¸°)
                                this.game.world.pasture.gate.isOpen = false; 
                                this.game.logMessage('ìš¸íƒ€ë¦¬ ë¬¸ì„ ë‹«ê³  ë°¤ì„ ë„˜ê²¼ìŠµë‹ˆë‹¤.');
                                
                                // Ensure end-of-day processes for the current day are completed exactly once
                                this.game.endOfDay(); // This will age sheep for the day just passed

                                // Manually advance day and set time to next morning
                                // Only increment day if we are skipping from the current day's evening/night (before natural midnight rollover)
                                const currentHourAtSkip = Math.floor(this.game.gameState.time / 60);
                                if (currentHourAtSkip >= 18) { // If skipping from 18:00 (6 PM) onwards
                                    this.game.gameState.day++; // Advance to next day
                                }
                                this.game.gameState.time = 6 * 60; // Set time to 6 AM of the new day (or current day if already past midnight)

                                // Explicitly call startOfDay for the new day.
                                // The _lastStartedDay flag will ensure it only runs once for this day.
                                this.game.startOfDay();

                                this.toggleConfirmModal(false);
                            }, () => {
                                // ì•„ë‹ˆì˜¤ (ì‹œê°„ ì•ˆ ë„˜ê¸°ê¸°)
                                this.game.world.pasture.gate.isOpen = false;
                                this.game.logMessage('ìš¸íƒ€ë¦¬ ë¬¸ì„ ë‹«ì•˜ìŠµë‹ˆë‹¤. ë°¤ì´ ê³„ì†ë©ë‹ˆë‹¤.');
                                this.toggleConfirmModal(false);
                            });
                        } else {
                            // ë‚®ì´ê±°ë‚˜, ë°¤ì´ì§€ë§Œ ë¬¸ì´ ë‹«í˜€ìˆìœ¼ë©´ ê·¸ëƒ¥ í† ê¸€
                            this.game.world.pasture.gate.isOpen = !this.game.world.pasture.gate.isOpen;
                            this.game.logMessage(`ìš¸íƒ€ë¦¬ ë¬¸ì„ ${this.game.world.pasture.gate.isOpen ? 'ì—´ì—ˆìŠµë‹ˆë‹¤' : 'ë‹«ì•˜ìŠµë‹ˆë‹¤'}.`);
                        }
                    }
                });
                this.marketButton.addEventListener('click', () => this.toggleMarketModal(true));
                this.hayActionButton.addEventListener('click', () => {
                    const distToHaystack = utils.distance(this.game.shepherd, this.game.world.pasture.haystack);
                    const distToTrough = utils.distance(this.game.shepherd, {x: this.game.world.pasture.trough.x + 50, y: this.game.world.pasture.trough.y + 10});
                    if (distToHaystack < 80) this.toggleHayModal(true, 'toTrough'); // ê±´ì´ˆë”ë¯¸ ê·¼ì²˜ -> ë¨¹ì´í†µìœ¼ë¡œ ì˜®ê¸°ê¸°
                    else if (distToTrough < 80) this.toggleHayModal(true, 'fromTrough'); // ë¨¹ì´í†µ ê·¼ì²˜ -> ì°½ê³ ë¡œ ë˜ëŒë¦¬ê¸°
                });
                this.dogCommandAllButton.addEventListener('click', () => {
                    const dogs = this.game.entities.filter(e => e instanceof Dog);
                    if (dogs.length > 0) { 
                        const newCommand = dogs[0].command === 'follow' ? 'stay' : 'follow'; 
                        dogs.forEach(d => d.command = newCommand); 
                        this.game.logMessage(`ëª¨ë“  ê°œì—ê²Œ '${newCommand === 'follow' ? 'ë”°ë¼ì™€' : 'ê¸°ë‹¤ë ¤'}' ëª…ë ¹ì„ ë‚´ë ¸ìŠµë‹ˆë‹¤.`);
                    }
                });
                this.dogStatusUI.addEventListener('click', (e) => {
                    const dogDiv = e.target.closest('.dog-status-item');
                    if (!dogDiv) return;
                    const dogId = Number(dogDiv.dataset.dogId);
                    const dog = this.game.entities.find(d => d instanceof Dog && d.id === dogId);
                    if (!dog) return;
                    dog.command = dog.command === 'follow' ? 'stay' : 'follow'; // ê°œë³„ ê°œ ëª…ë ¹ ë³€ê²½
                    this.game.logMessage(`${dog.name}ì—ê²Œ '${dog.command === 'follow' ? 'ë”°ë¼ì™€' : 'ê¸°ë‹¤ë ¤'}' ëª…ë ¹ì„ ë‚´ë ¸ìŠµë‹ˆë‹¤.`);
                });

                this.marketMessageDisplay = document.getElementById('market-message');
            }
            update() {
                const time = this.game.gameState.time; 
                const hour = Math.floor(time / 60) % 24; 
                const minute = Math.floor(time % 60);
                const period = hour < 12 ? 'ì˜¤ì „' : 'ì˜¤í›„'; 
                const displayHour = hour % 12 === 0 ? 12 : hour % 12;
                this.timeDisplay.textContent = `${period} ${String(displayHour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                this.dayDisplay.textContent = `Day ${this.game.gameState.day}`; 
                this.goldDisplay.textContent = this.game.gameState.gold;
                this.sheepDisplay.textContent = this.game.entities.filter(e => e instanceof Sheep).length;
                this.hayDisplay.textContent = this.game.gameState.hayStock;
                this.wolfSkinDisplay.textContent = this.game.gameState.wolfSkin; // ëŠ‘ëŒ€ ê°€ì£½ HUD ì—…ë°ì´íŠ¸

                const distToGate = utils.distance(this.game.shepherd, {x: this.game.world.pasture.gate.x + 40, y: this.game.world.pasture.gate.y + 10});
                // ë¬¸ ë²„íŠ¼ì€ ì–‘ì¹˜ê¸°ê°€ ë¬¸ ê·¼ì²˜ì— ìˆìœ¼ë©´ í•­ìƒ í‘œì‹œ
                this.gateButton.classList.toggle('hidden', !(distToGate < 100));
                // ë¬¸ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
                if (this.game.world.pasture.gate.isOpen) {
                    this.gateButton.innerHTML = 'ğŸšª ë¬¸ ë‹«ê¸°';
                } else {
                    this.gateButton.innerHTML = 'ğŸšª ë¬¸ ì—´ê¸°';
                }
                
                const inPasture = this.game.isInsidePasture(this.game.shepherd);
                this.marketButton.classList.toggle('hidden', !inPasture);

                const distToHaystack = utils.distance(this.game.shepherd, this.game.world.pasture.haystack);
                const distToTrough = utils.distance(this.game.shepherd, {x: this.game.world.pasture.trough.x + 50, y: this.game.world.pasture.trough.y + 10});
                const canAddToTrough = inPasture && distToHaystack < 80;
                const canTakeFromTrough = inPasture && distToTrough < 80;
                this.hayActionButton.classList.toggle('hidden', !(canAddToTrough || canTakeFromTrough));
                if (canAddToTrough) { this.hayActionButton.innerHTML = 'ï¿½ ê±´ì´ˆ ë„£ê¸°'; }
                else if (canTakeFromTrough) { this.hayActionButton.innerHTML = 'â†©ï¸ ê±´ì´ˆ ë˜ëŒë¦¬ê¸°'; }
                this.updateDogUI();
            }

            showMessage(message, type = 'error') {
                this.marketMessageDisplay.textContent = message;
                this.marketMessageDisplay.classList.remove('hidden');
                if (type === 'error') {
                    this.marketMessageDisplay.classList.remove('text-green-600');
                    this.marketMessageDisplay.classList.add('text-red-600');
                } else {
                    this.marketMessageDisplay.classList.remove('text-red-600');
                    this.marketMessageDisplay.classList.add('text-green-600');
                }
                setTimeout(() => {
                    this.marketMessageDisplay.classList.add('hidden');
                }, 3000); // 3ì´ˆ í›„ ë©”ì‹œì§€ ìˆ¨ê¹€
            }

            updateDogUI() {
                // Sort dogs by ID to ensure consistent display order in fixed slots
                const dogs = this.game.entities.filter(e => e instanceof Dog).sort((a, b) => a.id - b.id);
                
                // Update visibility of the "command all" button
                this.dogCommandAllButton.classList.toggle('hidden', dogs.length === 0);
                
                // Create a snapshot string for change detection, including the count of active dogs
                const currentDogInfo = dogs.map(d => `${d.id}:${d.command}:${d.name}`).join('|');
                const newSnapshot = `${dogs.length}|${currentDogInfo}`;

                // Only re-render if the state of dogs has actually changed
                if (this._dogStatusSnapshot === newSnapshot) {
                    return;
                }
                this._dogStatusSnapshot = newSnapshot; // Update snapshot

                this.dogStatusUI.innerHTML = ''; // Clear existing buttons

                // Render up to 3 fixed slots for dog buttons
                for (let i = 0; i < 3; i++) {
                    const dogDiv = document.createElement('div');
                    // Apply fixed width and centering classes to prevent layout shifts
                    dogDiv.className = 'hud-item dog-status-item w-32 flex-none flex flex-col items-center justify-center'; 
                    
                    const dog = dogs[i]; // Get the dog for this slot, if it exists

                    if (dog) {
                        dogDiv.dataset.dogId = String(dog.id);
                        const label = (dog.command === 'follow') ? 'ë”°ë¼ì™€' : 'ê¸°ë‹¤ë ¤';
                        // Ensured text is block and centered for two lines
                        dogDiv.innerHTML = `<span class="block text-center">ğŸ¶ ${dog.name}</span> <span class="block text-xs text-center">${label}</span>`;
                        dogDiv.classList.add('cursor-pointer'); // Make it clickable
                        // Event listener is handled by delegation on the parent dogStatusUI, no need to attach here
                    } else {
                        // Empty slot: "ì…ì–‘ í•„ìš”"
                        dogDiv.classList.remove('cursor-pointer'); // Not clickable
                        dogDiv.style.opacity = '0.7'; // Slightly dimmed for empty slots
                        // Ensured text is block and centered for two lines
                        dogDiv.innerHTML = `<span class="block text-center">ğŸ•</span> <span class="block text-xs text-center">ì…ì–‘ í•„ìš”</span>`;
                    }
                    this.dogStatusUI.appendChild(dogDiv);
                }
            }
            toggleMarketModal(show) {
                document.getElementById('market-modal').classList.toggle('hidden', !show);
                this.game.gameState.paused = show; // ê²Œì„ ì¼ì‹œ ì •ì§€/ì¬ê°œ
                if (show) this.setupMarketModal(); // ëª¨ë‹¬ì´ ë³´ì¼ ë•Œë§ˆë‹¤ ì‹œì¥ ì •ë³´ ì—…ë°ì´íŠ¸
            }
            setupMarketModal() {
                const buySection = document.getElementById('market-buy-section');
                const sellSection = document.getElementById('market-sell-section');
                
                // êµ¬ë§¤ ì„¹ì…˜ ì´ˆê¸°í™” ë° ì—…ë°ì´íŠ¸
                buySection.innerHTML = `
                    <h3 class="font-bold mb-2 text-lg">êµ¬ë§¤</h3>
                    <div id="gold-info-buy" class="text-sm mb-2">í˜„ì¬ ê³¨ë“œ: ${this.game.gameState.gold}</div>
                `;
                
                // íŒë§¤ ì„¹ì…˜ ì´ˆê¸°í™” ë° ì—…ë°ì´íŠ¸
                sellSection.innerHTML = `
                    <h3 class="font-bold mb-2 text-lg">íŒë§¤</h3>
                    <div id="gold-info-sell" class="text-sm mb-2">í˜„ì¬ ê³¨ë“œ: ${this.game.gameState.gold}</div>
                `;

                const createItemHTML = (name, price, current, action) => {
                    const itemId = `${action}-${name.replace(/ /g, '_')}`;
                    let maxQty = 0;
                    if (action === 'buy') {
                        if (name === 'ìƒˆë¼ ì–‘') maxQty = Math.floor(this.game.gameState.gold / 5);
                        else if (name === 'ì–´ë¥¸ ì–‘') maxQty = Math.floor(this.game.gameState.gold / 10);
                        else if (name === 'ê°œ') {
                            const currentDogCount = this.game.entities.filter(e => e instanceof Dog).length;
                            maxQty = Math.min(Math.floor(this.game.gameState.gold / 50), 3 - currentDogCount); // ê°œëŠ” ìµœëŒ€ 3ë§ˆë¦¬
                        }
                        else if (name === 'ê±´ì´ˆ') maxQty = Math.floor(this.game.gameState.gold / 1);
                        maxQty = Math.max(0, maxQty); // ìŒìˆ˜ê°€ ë˜ì§€ ì•Šë„ë¡
                    } else { // sell
                        if (name === 'ìƒˆë¼ ì–‘') {
                            maxQty = this.game.entities.filter(e => e instanceof Sheep && !e.isAdult && this.game.isInsidePasture(e)).length;
                        } else if (name === 'ì–´ë¥¸ ì–‘') {
                            maxQty = this.game.entities.filter(e => e instanceof Sheep && e.isAdult && this.game.isInsidePasture(e)).length;
                        } else if (name === 'ëŠ‘ëŒ€ ê°€ì£½') {
                            maxQty = this.game.gameState.wolfSkin;
                        }
                    }

                    const isDisabled = maxQty === 0 ? 'disabled' : '';
                    // ìŠ¬ë¼ì´ë” ì´ˆê¸°ê°’: maxQtyê°€ 0ì´ë©´ 0, ì•„ë‹ˆë©´ 1
                    const initialSliderValue = maxQty === 0 ? 0 : 1;
                    
                    return `
                        <div class="bg-gray-100 p-3 rounded-md">
                            <p class="font-semibold">${name} <span class="text-sm font-normal">(${price} ê³¨ë“œ)</span></p>
                            <p class="text-sm text-gray-600">ë³´ìœ : ${current}</p>
                            <div class="flex items-center gap-2 mt-2">
                                <span class="text-lg w-8 text-center" id="${itemId}-display">${initialSliderValue}</span>
                                <input id="${itemId}-qty" type="range" value="${initialSliderValue}" min="0" max="${maxQty}" class="flex-1" oninput="document.getElementById('${itemId}-display').textContent=this.value" ${isDisabled}>
                                <button onclick="game.market.${action}('${name.replace(/ /g, '_')}')" class="bg-blue-500 text-white p-1 rounded-md text-sm ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}" ${isDisabled}>${action === 'buy' ? 'êµ¬ë§¤' : 'íŒë§¤'}</button>
                            </div>
                        </div>`;
                };

                // í˜„ì¬ ë³´ìœ í•œ ì–‘, ê°œ, ê±´ì´ˆ, ëŠ‘ëŒ€ ê°€ì£½ ìˆ˜ ì—…ë°ì´íŠ¸
                const youngSheepCount = this.game.entities.filter(e=>e instanceof Sheep && !e.isAdult).length;
                const adultSheepCount = this.game.entities.filter(e=>e instanceof Sheep && e.isAdult).length;
                const dogCount = this.game.entities.filter(e=>e instanceof Dog).length;
                const hayStockCount = this.game.gameState.hayStock;
                const wolfSkinCount = this.game.gameState.wolfSkin;

                buySection.innerHTML += createItemHTML('ìƒˆë¼ ì–‘', 5, youngSheepCount, 'buy');
                buySection.innerHTML += createItemHTML('ì–´ë¥¸ ì–‘', 10, adultSheepCount, 'buy');
                buySection.innerHTML += createItemHTML('ê°œ', 50, dogCount, 'buy');
                buySection.innerHTML += createItemHTML('ê±´ì´ˆ', 1, hayStockCount, 'buy');
                
                // ëª©ì¥ ì•ˆì— ìˆëŠ” íŒë§¤ ê°€ëŠ¥í•œ ì–‘ë§Œ ê³„ì‚°
                const sellableYoungSheep = this.game.entities.filter(e=>e instanceof Sheep && !e.isAdult && this.game.isInsidePasture(e)).length;
                const sellableAdultSheep = this.game.entities.filter(e=>e instanceof Sheep && e.isAdult && this.game.isInsidePasture(e)).length;

                sellSection.innerHTML += createItemHTML('ìƒˆë¼ ì–‘', 2, sellableYoungSheep, 'sell');
                sellSection.innerHTML += createItemHTML('ì–´ë¥¸ ì–‘', 5, sellableAdultSheep, 'sell');
                sellSection.innerHTML += createItemHTML('ëŠ‘ëŒ€ ê°€ì£½', 1, wolfSkinCount, 'sell'); // ëŠ‘ëŒ€ ê°€ì£½ íŒë§¤ ì¶”ê°€
            }
            toggleHayModal(show, direction = 'toTrough') {
                document.getElementById('hay-modal').classList.toggle('hidden', !show);
                this.game.gameState.paused = show;
                if (show) this.setupHayModal(direction);
            }
            setupHayModal(direction) {
                const title = document.getElementById('hay-modal-title');
                const info = document.getElementById('hay-modal-info');
                const input = document.getElementById('hay-quantity-input');
                const slider = document.getElementById('hay-quantity-slider');
                const confirmBtn = document.getElementById('hay-confirm-button');
                const minusBtn = document.getElementById('hay-quantity-minus');
                const plusBtn = document.getElementById('hay-quantity-plus');
                const trough = this.game.world.pasture.trough;
                
                const totalTroughHay = this.game.calculateTroughHayAmount();
                const totalTroughMaxHay = this.game.calculateTroughMaxHay();
                
                let max = 0;
                if (direction === 'toTrough') {
                    title.textContent = "ì°½ê³  â†’ ë¨¹ì´í†µ";
                    max = Math.floor(Math.min(this.game.gameState.hayStock, totalTroughMaxHay - totalTroughHay));
                    info.textContent = `ì°½ê³  ë³´ìœ ëŸ‰: ${this.game.gameState.hayStock}, ë¨¹ì´í†µ ì—¬ìœ : ${Math.floor(totalTroughMaxHay - totalTroughHay)}`;
                } else {
                    title.textContent = "ë¨¹ì´í†µ â†’ ì°½ê³ ";
                    max = Math.floor(totalTroughHay);
                    info.textContent = `ë¨¹ì´í†µ ë³´ìœ ëŸ‰: ${Math.floor(totalTroughHay)}`;
                }
                input.max = max; slider.max = max;
                input.value = max > 0 ? 1 : 0; slider.value = max > 0 ? 1 : 0;
                const syncValues = (source) => {
                    const value = Math.max(1, Math.min(max, parseInt(source.value)));
                    input.value = value; slider.value = value;
                };
                input.oninput = () => syncValues(input);
                slider.oninput = () => syncValues(slider);
                minusBtn.onclick = () => { input.value = Math.max(1, parseInt(input.value) - 1); syncValues(input); };
                plusBtn.onclick = () => { input.value = Math.min(max, parseInt(input.value) + 1); syncValues(input); };
                confirmBtn.onclick = () => {
                    const quantity = parseInt(input.value);
                    if (quantity > 0 && quantity <= max) this.game.transferHay(direction, quantity);
                    this.toggleHayModal(false);
                };
            }
            toggleSheepInfoModal(show, sheep = null) {
                const modal = document.getElementById('sheep-info-modal');
                modal.classList.toggle('hidden', !show);
                this.game.gameState.paused = show;

                if (show && sheep) {
                    const input = document.getElementById('sheep-name-input');
                    const statusInfo = document.getElementById('sheep-status-info');
                    const confirmBtn = document.getElementById('sheep-info-confirm');
                    
                    input.value = sheep.name;
                    
                    if (sheep.isAdult) {
                        if (sheep.breedingCooldown > 0) {
                            statusInfo.textContent = `ìƒì‹ê¹Œì§€ ${sheep.breedingCooldown}ì¼ ë‚¨ìŒ`;
                        } else {
                            statusInfo.textContent = 'ë²ˆì‹ ê°€ëŠ¥';
                        }
                    } else {
                        const daysToGrow = 7 - sheep.age;
                        statusInfo.textContent = `ì„±ì¥ê¹Œì§€ ${daysToGrow}ì¼ ë‚¨ìŒ`;
                    }

                    input.focus();
                    confirmBtn.onclick = () => {
                        if (input.value) {
                            sheep.name = input.value.substring(0, 15);
                        }
                        this.toggleSheepInfoModal(false);
                    };
                }
            }
            toggleDogInfoModal(show, dog = null) {
                const modal = document.getElementById('dog-info-modal');
                modal.classList.toggle('hidden', !show);
                this.game.gameState.paused = show;

                if (show && dog) {
                    const input = document.getElementById('dog-name-input');
                    const confirmBtn = document.getElementById('dog-info-confirm');
                    
                    input.value = dog.name;
                    input.focus();
                    
                    confirmBtn.onclick = () => {
                        if (input.value) {
                            dog.name = input.value.substring(0, 15);
                        }
                        this.toggleDogInfoModal(false);
                    };
                }
            }
            showGameOverModal() {
                document.getElementById('game-over-modal').classList.remove('hidden');
                document.getElementById('game-over-stats').textContent = `ìƒì¡´ ì¼ì: ${this.game.gameState.day}ì¼, ë³´ìœ  ê³¨ë“œ: ${this.game.gameState.gold}`;
            }

            // í˜„ì¬ ì‹œê°„ì„ "ì˜¤ì „/ì˜¤í›„ HH:MM" í˜•ì‹ìœ¼ë¡œ ë°˜í™˜í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
            getFormattedTime() {
                const time = this.game.gameState.time;
                const hour = Math.floor(time / 60) % 24;
                const minute = Math.floor(time % 60);
                const period = hour < 12 ? 'ì˜¤ì „' : 'ì˜¤í›„';
                const displayHour = hour % 12 === 0 ? 12 : hour % 12;
                return `${period} ${String(displayHour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
            }

            // ìƒˆë¡œìš´ í™•ì¸ ëª¨ë‹¬ í† ê¸€ í•¨ìˆ˜
            toggleConfirmModal(show, message = '', onConfirm = () => {}, onCancel = () => {}) {
                this.confirmModal.classList.toggle('hidden', !show);
                this.game.gameState.paused = show; // ëª¨ë‹¬ì´ ëœ° ë•Œ ê²Œì„ ì¼ì‹œ ì •ì§€

                if (show) {
                    this.confirmMessage.textContent = message;
                    this.confirmYesButton.onclick = () => {
                        onConfirm();
                        this.toggleConfirmModal(false);
                    };
                    this.confirmNoButton.onclick = () => {
                        onCancel();
                        this.toggleConfirmModal(false);
                    };
                }
            }
        }
        
        class Market {
            constructor(game) { this.game = game; }
            buy(item) {
                const qtyInput = document.getElementById(`buy-${item}-qty`);
                const qty = parseInt(qtyInput.value);
                if (isNaN(qty) || qty <= 0) {
                    this.game.ui.showMessage("êµ¬ë§¤ ìˆ˜ëŸ‰ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", 'error');
                    return;
                }
                const costs = { 'ìƒˆë¼_ì–‘': 5, 'ì–´ë¥¸_ì–‘': 10, 'ê°œ': 50, 'ê±´ì´ˆ': 1 };
                const totalCost = costs[item] * qty;
                if (this.game.gameState.gold >= totalCost) {
                    if (item === 'ê°œ' && this.game.entities.filter(e => e instanceof Dog).length + qty > 3) { 
                        this.game.ui.showMessage("ê°œëŠ” ìµœëŒ€ 3ë§ˆë¦¬ê¹Œì§€ ë³´ìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.", 'error'); 
                        return; 
                    }
                    this.game.gameState.gold -= totalCost;
                    const pos = {x: this.game.shepherd.x, y: this.game.shepherd.y};
                    for(let i=0; i<qty; i++) {
                        if (item === 'ìƒˆë¼_ì–‘') this.game.entities.push(new Sheep(this.game, pos.x, pos.y, false));
                        if (item === 'ì–´ë¥¸_ì–‘') this.game.entities.push(new Sheep(this.game, pos.x, pos.y, true));
                        if (item === 'ê°œ') this.game.entities.push(new Dog(this.game, pos.x, pos.y));
                        if (item === 'ê±´ì´ˆ') this.game.gameState.hayStock++;
                    }
                    this.game.ui.showMessage(`${qty} ${item.replace('_', ' ')} êµ¬ë§¤ ì™„ë£Œ!`, 'success');
                    this.game.logMessage(`${qty} ${item.replace('_', ' ')}ì„(ë¥¼) êµ¬ë§¤í–ˆìŠµë‹ˆë‹¤. (ë‚¨ì€ ê³¨ë“œ: ${this.game.gameState.gold})`);
                    this.game.ui.setupMarketModal(); // ê±°ë˜ í›„ UI ì—…ë°ì´íŠ¸
                } else { 
                    this.game.ui.showMessage("ê³¨ë“œê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.", 'error'); 
                }
            }
            sell(item) {
                const qtyInput = document.getElementById(`sell-${item}-qty`);
                const qty = parseInt(qtyInput.value);
                if (isNaN(qty) || qty <= 0) {
                    this.game.ui.showMessage("íŒë§¤ ìˆ˜ëŸ‰ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", 'error');
                    return;
                }
                const prices = { 'ìƒˆë¼_ì–‘': 2, 'ì–´ë¥¸_ì–‘': 5, 'ëŠ‘ëŒ€_ê°€ì£½': 1 }; // ëŠ‘ëŒ€ ê°€ì£½ íŒë§¤ ê°€ê²© ì¶”ê°€
                
                if (item === 'ìƒˆë¼_ì–‘' || item === 'ì–´ë¥¸_ì–‘') {
                    const isAdult = item === 'ì–´ë¥¸_ì–‘';
                    const sheepToSell = this.game.entities.filter(e => e instanceof Sheep && e.isAdult === isAdult && this.game.isInsidePasture(e));
                    if (sheepToSell.length >= qty) {
                        for(let i=0; i<qty; i++) {
                            sheepToSell[i].isDead = true;
                            this.game.logMessage(`${sheepToSell[i].name}ì´(ê°€) ì‹œì¥ì— íŒë§¤ë˜ì—ˆìŠµë‹ˆë‹¤.`); // íŒë§¤ ë¡œê·¸ ê¸°ë¡
                            sheepToSell[i].deathLogged = true; // ì‚¬ë§ ë¡œê·¸ ì¤‘ë³µ ë°©ì§€
                        }
                        this.game.gameState.gold += prices[item] * qty;
                        this.game.ui.showMessage(`${qty} ${item.replace('_', ' ')} íŒë§¤ ì™„ë£Œ!`, 'success');
                        this.game.logMessage(`${qty} ${item.replace('_', ' ')}ì„(ë¥¼) íŒë§¤í–ˆìŠµë‹ˆë‹¤. (ì´ ê³¨ë“œ: ${this.game.gameState.gold})`);
                        this.game.ui.setupMarketModal(); // ê±°ë˜ í›„ UI ì—…ë°ì´íŠ¸
                    } else { 
                        this.game.ui.showMessage(`ëª©ì¥ ì•ˆì— íŒë§¤í•  ${isAdult ? 'ì–´ë¥¸ ì–‘' : 'ìƒˆë¼ ì–‘'}ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.`, 'error'); 
                    }
                } else if (item === 'ëŠ‘ëŒ€_ê°€ì£½') {
                    if (this.game.gameState.wolfSkin >= qty) {
                        this.game.gameState.wolfSkin -= qty;
                        this.game.gameState.gold += prices[item] * qty;
                        this.game.ui.showMessage(`${qty} ëŠ‘ëŒ€ ê°€ì£½ íŒë§¤ ì™„ë£Œ!`, 'success');
                        this.game.logMessage(`${qty} ëŠ‘ëŒ€ ê°€ì£½ì„ íŒë§¤í–ˆìŠµë‹ˆë‹¤. (ì´ ê³¨ë“œ: ${this.game.gameState.gold})`);
                        this.game.ui.setupMarketModal(); // ê±°ë˜ í›„ UI ì—…ë°ì´íŠ¸
                    } else {
                        this.game.ui.showMessage("ë³´ìœ í•œ ëŠ‘ëŒ€ ê°€ì£½ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.", 'error');
                    }
                }
            }
        }

        // --- ê²Œì„ ì´ˆê¸°í™” ë° ì‹¤í–‰ ---
        const canvas = document.getElementById('gameCanvas');
        const game = new Game(canvas);
        game.start();

    </script>
</body>
</html>
ï¿½